//哈夫曼树
//1.带权路径长度
//2.哈夫曼树的定义
//3.哈夫曼树的构造（重点）
//4.哈夫曼树的编码（重点）
//*******************
//1.节点的权：带有某种现实含义的数值（如：表示节点的重要性）
//节点的带权路径长度：从树的根到该节点的路径长度（经历的边数）与该节点权值的乘积
//树的带权路径的长度：树中所有叶节点的带权路径长度之和（WPL)
//*********************
//2.在含有n个带权叶节点的二叉树中。其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树
//**********************
//3.给定n个权重分别为w1,w2,……，wn的节点，构造哈夫曼树的算法描述如下：
//1）将这n个节点分别作为n棵仅含一个节点的二叉树，构成森林F.
//2)构造一个新节点，从F中选取两棵根节点权值最小的树作为新节点的左右子树，并将新节点的权值置为左右子树上根节点的权值之和。
//3）从F中删除刚才选出的两棵树，同时将新得到，的树加入F中。
//4）重复步骤2）和3），直到F中只剩下一棵树为止。
//每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径越大
//哈夫曼树的节点总数为2n-1
//哈夫曼树中不存在度为1的节点
//哈夫曼树并不唯一，但WPL多都相同且为最优
//****************************
//可变长度编码――――允许对不同字符用不等二进制位来表示
//若没有一个编码是另一个编码的前缀，则称为这样的编码位前缀编码
//有哈夫曼树得到哈夫曼编码---字符集中的每个字符作为一个叶子节点，各个字符出现的频度作为节点的权值，根据之前介绍的方法构造哈夫曼树
//所以哈夫曼编码可以用于数据的压缩（也就是我们常见的压缩包的压缩形式）
//计算哈夫曼树的压缩率步骤
//计算原始数据的大小：
//
//字符串的每个字符用固定的位数表示（例如，ASCII编码通常是8位），根据字符的总数计算原始数据的大小。
//原始数据大小（以位为单位） = 字符总数 × 每个字符的位数
//构建哈夫曼树：
//
//根据每个字符的出现频率构建哈夫曼树，生成每个字符的哈夫曼编码。字符出现的频率越高，分配的编码位数越短。
//计算哈夫曼编码后的数据大小：
//
//将每个字符的哈夫曼编码长度乘以该字符的频率，并将所有这些乘积加起来，得到编码后的数据大小。
//哈夫曼压缩后数据大小 = Σ（每个字符的哈夫曼编码长度 × 该字符的频率）
//计算压缩率：
//
//压缩率可以定义为：
//压缩率=（原始数据大小?哈夫曼编码后数据大小）/原始数据大小×100%

//这里的结果是一个百分比，越高的压缩率表示压缩效果越好。
//举个例子
//假设我们有一个字符串 "aaaabbc"，其字符频率如下：
//
//'a'：4次
//'b'：2次
//'c'：1次
//
//原始数据大小 = 7字符 × 8位 / 字符 = 56位
//构建哈夫曼树，得到可能的编码：
//
//假设 'a' 编码为 0，'b' 编码为 10，'c' 编码为 11。
//哈夫曼编码后的数据大小：
//
//'a'：4 × 1 = 4位
//'b'：2 × 2 = 4位
//'c'：1 × 2 = 2位
//总和 = 4 + 4 + 2 = 10位
//计算压缩率：
//
//压缩率=（56-10）/56*100%约等于82.14%
//一般情况下，哈夫曼树可能会考察的内容包括：
//哈夫曼树的构建：
//
//题目可能要求你实现哈夫曼树的构建算法，包括创建哈夫曼树所需的优先队列或最小堆的使用。
//哈夫曼编码的生成：
//
//考察生成哈夫曼编码的过程，能够根据字符频率生成对应的编码。
//哈夫曼编码解码：
//
//可能会考察如何利用哈夫曼树对编码后的数据进行解码。
//相关算法的时间复杂度：
//
//需要能够分析和解释哈夫曼树构建的时间复杂度。