//编码代码实现：求一个整数存储在内存中的二进制中1的个数
//求补码的二进制中1的个数(内存中存的就是补码）
//int a = 3;
//00000000000000000000000000000011 2^0*1+2^1*1=3（三的二进制序列）
//a&1(按位与，有0，取0）
//00000000000000000000000000000011 a 通过位操作符（就能一个接一个，来确认有几个1）
//00000000000000000000000000000001 1
//00000000000000000000000000000001（最后一位是1，得到的结果就是1）
//00000000000000000000000000000010 a
//00000000000000000000000000000001 1
//00000000000000000000000000000000（最后一位是0，得到的结果就是0）
//>> <<
//思路如上
//赋值操作符
//要注意的一点就是可以连续赋值
//如：a=x=y+1;从左到右；假如：y=1,那么x就会被赋予2，然后a就会变成2（可以写，但不建议）
//复合赋值符
#include<stdio.h>
//int main()
//{
//	////int a = 3;
//	////a = a + 5;
//	////a += 5;/*两种都是一样的意思*/
//	//int a = 10;//1010 10
//	//printf("初始值：%d\n", a);
//	////a = a >> 1;
//	//a >>= 1;//a向右移动1位
//	//printf("右移一位后： %d\n", a);//101 5
//	//&= 与赋值操作符
//	//a &= b等价于a = a&b
//	//还有|=，^=.分别叫做或赋值，异或赋值
//	return 0;
//}
//单目操作符（只有一个操作符）（a+b)是双目操作符
//！ 逻辑反操作符
//int main()
//{
//	int flag = 3;
//	//flag为真，进入if
//	if(flag)
//	{ }
//	//flag为假，进入if
//	if(!flag)
//	{ }
//	return 0;
//}
//还有 +，-,&,sizeof(用来算变量所占内存的大小)
//~(波浪号） 对一个数的二进制按位取反
int main()
{
//	int a = 0;
//	//~是按二进制按位取反
//	//00000000000000000000000000000000 -补码
////结果11111111111111111111111111111111-》~a(补码）
//	//因为1开头（-1取反）
//	//10000000000000000000000000000001 ~a(原码） -1
//	printf("%d\n", ~a);//-1
//	return 0;
	//int a = 3;
	////000000000000000000000000000000011->原码和补码（a)
	////111111111111111111111111111111100-》补码（~a)
	////111111111111111111111111111111011(-1)
	////100000000000000000000000000000100(取反）原码（~a) -4
	//printf("%d\n", ~a);
	//用于对不满意的值进行修改(这个很细）
	int a = 13;
	//思路：
	//000000000000000000000000000001101(修改)
	//                   假如要修改（！）这个值！上面这个
	//000000000000000000000000000000010（这个是我需要的）
	//怎么获得呢？
	//000000000000000000000000000000001（这个是1）
	//然后用<<1，向左移一位，就ok了
	//因为按位或（|）是有1，则改1
	//放下来看
	//000000000000000000000000000001101
	//000000000000000000000000000000010
	//这两个通过按位或{|}
	//就能的到：
	//000000000000000000000000000001111 （15）
	/*a |= (1 << 1);
	printf("%d\n", a);*/
	return 0;
}
//(用处不大，但是得会)