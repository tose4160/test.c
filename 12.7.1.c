//图的存储---邻接矩阵法
//解释：在无向图中x轴，y轴都是从小到大
//如:A B C D
//A  0 1 0 0
//B  1 0 0 0
//C  0 0 0 0
//在其中1表示相邻，0表示不相邻
//在无向图中一般这个图是一定是对称的
//在有向图中，就只从上面的图第一行来看的话，那个1的意思就是A指向B,所以有相图可以不对称
//这种方法的代码实现很简单
//定义一个结构体：
//用char存放顶点
//定义一个二维数组构成一个邻接矩阵
//最后定义两个变量用来记录顶点的个数和边的个数
//**************
// 无向图
//求第i个节点的度=第i行的非零元素的个数
// 有向图
////求第i个节点的出度=第i行的非零元素的个数（行）
////求第i个节点的入度=第i行的非零元素的个数（列）
//度等于入度加出度
//时间复杂度为O(n)
//*************
//邻接矩阵法存储带权图（网）（考研倾向）
//用定义的一个最大值表示无穷，用相应的数值替换1表示权重
#define MaxVertexNum 100//定点数的最大值
#define INFINTY 999//最大的int值//宏定义表示无穷
typedef char VertexType;//顶点的数据类型
typedef int EdgeType;//带权图中边上权值的数据类型
typedef struct
{
	VertexType Vex[MaxVertexNum];//顶点
	EdgeType Edge[MaxVertexNum][MaxVertexNum];//边的权
	int vexnum, arcnum; //图的当前顶点数和弧度
}MGraph;
//有的时候带权图会把自己指向自己的点设置为0
//性能分析：
//时间复杂度：O(n^2)---只与顶点数相关，和实际边数无关
//这种方法适合存储稠密图
//无向图可以采用压缩存储的方法
//********************
//邻接矩阵法的性质（略难）
//设图G的邻接矩阵为A,则A^n的元素A^n[i][j]等于有顶点i到顶点j的长度为n的路径的数目（涉及线性代数）