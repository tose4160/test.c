
////在C语言中，enum（枚举）用于定义一组命名的整型常量。枚举中的每个值自动从0开始递增，除非显式指定了其他值。让我们来分析给定的枚举定义：
//enum data
//{
//    MIN,        // 默认值为 0  
//    first = 15, // 手动指定为 15  
//    last = 20,  // 手动指定为 20  
//    total,      // 继承上一个定义的值，即 21  
//    num = 50,   // 手动指定为 50  
//    MAX = 1000  // 手动指定为 1000  
//};
//根据这个定义，我们可以确定以下值：
//
//MIN 的值为： 0（因为是第一个未显示指定的枚举常量）
//total 的值为： 21（因为它是在last（20）的基础上递增得到的）
//因此，答案是：
//
//MIN 的值为： 0
//total 的值为： 21
// //************************
//#include <stdio.h>
//struct stu
//{
//    int x;
//    int* y;
//}*p;
//int dt[4] = { 10,20,30,40 };
//struct stu a[4] = { 40,&dt[0],50,&dt[1],60,&dt[2],70,&dt[3] };
//int main()
//{
//    p = a;
//    printf("%d,", ++p->x);
//    printf("%d,", (++p)->x);
//    printf("%d", ++(*p->y));
//    return 0;
//}
//各行分析
//第一行：printf("%d,", ++p->x);
//
//p->x代表的是a[0].x，即40。
//使用++p->x会使这个值递增1，变成41，同时p->x返回41。
//输出结果为 41, 。
//第二行：printf("%d,", (++p)->x);
//
//++p使得p指向下一个结构体，即a[1]。
//此时p->x对应的是50。
//因此，输出结果为 50, 。
//第三行：printf("%d", ++(*p->y));
//
//此时p->y是a[1].y，它指向& dt[1]。
//dt[1]原先的值是20。
//* p->y解引用得到dt[1]的值20，执行++(*p->y)会将其值递增1，这个值会变成21。
//此时，dt[1]存储的值更新为21，所以输出为 21。
//详细说明
//当程序执行到第三行时，通过(*p->y)取到了指向的dt[1]的值20，然后执行++操作，表示“将dt[1]的值递增1”。这会直接修改dt[1]在内存中存储的值，因此它从20变成了21。所以最后这行输出的是21。
//
//最终结果
//把各行的输出结果组合起来，最后的输出为：
//
//41, 50, 21
//*******************
//输入输出三位学生学号、姓名
//#include <stdio.h>  
//
//int main(void)
//{
//    struct student
//    {
//        int num;
//        char name[10];
//    } stu[3], * ptr;
//    int i;
//
//    for (i = 0; i < 3; i++)
//    {
//        scanf("%d,%s", &stu[i].num, stu[i].name);
//    }
//
//    for (ptr = stu; ptr < stu + 3; ptr++) // 指针ptr从stu开始，直到stu数组的结束  
//    {
//        printf("%d,%s\n", ptr->num, ptr->name);
//    }
//
//    return 0;
//}
// 在芸芸众生中，我们每个人都有自己的一些属性，每个人都有一个或者多个属于自己的标签。
// 就如同游戏英雄联盟中的英雄一样，一个英雄有他的血量，蓝条，攻击力等一系列属性，然后这些属性都有一个特定的数值来标识他们的强弱。定义两个英雄角色，通过其攻击力比较，输出相应的信息。
//#include<stdio.h>
//struct Hero {
//    char name[20];//英雄的名字
//    double Health_value;//英雄的血量
//    int aggressivity;//攻击力
//};
//int main() {
//    struct Hero
//        hero[2]
//        ;//定义两个struct Hero的英雄
//    for (int i = 0; i < 2; i++)//初始化每个英雄的基本属性
//        scanf_s("%s %lf %d", &hero[i].name, &hero[i].Health_value, &hero[i].aggressivity);// 读取英雄名字，无需使用数组大小  
//    if (
//        hero[0].aggressivity > hero[1].aggressivity
//        )
//    {
//        printf("英雄 %s 的攻击力大于英雄 %s 的攻击力\n", hero[0].name, hero[1].name);
//    }
//    else
//    {
//        printf("英雄 %s 的攻击力大于英雄 %s 的攻击力\n", hero[1].name, hero[0].name);
//    }
//
//    return 0;
//}
