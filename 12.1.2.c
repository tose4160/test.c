//在中序线索二叉树找中序后继
// 
// 中序线索二叉树的关键概念
//线索化：在中序线索二叉树中，除了传统的左右子女指针，节点的右指针(rchild) 可以被用来指向其在中序遍历中的后继节点。这里的 rtag 用于标记右指针的含义：
//
//如果 rtag 是 0，表示 rchild 指向的是真正的右子树。
//如果 rtag 是 1，表示 rchild 指向的是该节点的中序后继（线索）。
//中序后继：对于一个节点 P，其后继是指在中序遍历中紧接着 P 的下一个节点。
// 
// 
//在中序线索二叉树中找到指定节点*p的中序后继节点next
//1.若P->rtag==1,则next=p->rchild//rtag==1表示线索化了，后继节点就是rchild
// 详细解释：为什么P->rtag == 1表示后继节点是P->rchild
//P->rtag == 1的意义：当我们检查到 P->rtag == 1时，说明当前节点 P 的右指针实际上是用来指向它的中序后继，而不是一个右子树。这个标签的使用是为了进行线索化，
// 使得我们可以在没有栈或递归的情况下，更快地找到后继节点。
//
//next = P->rchild的赋值：如果 P->rtag == 1，那么 next = P->rchild 就是正确的。这里的 P->rchild 直接指向节点 P 的中序后继。这样，
// 在进行中序遍历时，我们可以直接利用这个信息跳转到后继节点，避免了传统遍历需要访问父节点或其他复杂操作的步骤。
//
//具体示例
//假设我们有以下的中序线索二叉树：
//     4
//    / \
//   2   6
//  / \ / \
// 1  3 5  7
//在这个树中，假设我们在线索化之后，3 的右指针（即 rchild）是指向 4（它的中序后继），并且我们设定 3->rtag = 1。
//
//访问节点 3，读到 3->rtag 的值为 1。
//依据定义，next = 3->rchild，此时 next 实际上就是 4，也就是 3 的中序后继。
//2.若p->rtag==0,
// 在中序线索二叉树中，当 rtag == 0 时，表示节点的右指针 rchild 指向的是其真实的右子树，而不是中序后继节点。在这种情况下，获取中序后继节点的过程会有所不同。
//如何找到后继节点（rtag == 0）
//检查右子树：如果节点 P 的 rtag 为 0，说明 P 有一个右子树。
//
//在这种情况下，节点 P 的后继节点是其右子树中的最左节点。也就是说，要找 P 的后继，就需要进入 P 的右子树，然后顺着左孩子一直向下，直到找到最左边的节点。
//寻找最左节点的步骤：
//
//从节点 P 的右孩子开始，向左遍历，直到找到一个没有左孩子的节点。这个节点就是 P 的中序后继。
//示例
//假设我们有一个中序线索二叉树如下：
//
//      4
//     / \
//    2   6
//   / \ / \
//  1  3 5  7
//如果我们要找节点 4 的后继：
//
//4 的 rtag 为 0，说明 4 有右子树。//////rtag==0，就代表节点的右子树还没有线索化，所以就代表该节点存在右子树，（我的理解）
//                                    //特别声明：右子树可能为NULL,这同样代表着程序结束。
//4 的右孩子是 6，这是其右子树的根节点。
//进入右子树，开始寻找最左节点，从 6 开始，观察 6 的左孩子是 5，然后我们继续遍历左孩子，但 5 没有左孩子。
//因此，5 就是 4 的后继节点。
//总结
//当 rtag == 0 时，意味着后继节点不在当前节点的右指针上，
//我们需要通过右子树来找到后继。通过进入右子树并找到最左节点，完成后继查找。
//这一设计通过分离线索和真实的孩子指针，使树的遍历和后继查找变得更加高效
// 
// 代码：
// //找到一p为根的子树，第一个被中序遍历的节点
// //循环找到最左下节（不一定是叶节点）
// ThreadNode *Firstnode(ThreadNode *p)
// {
// while(p->ltag==0)
// p=p->lchild;
// return p;
// }
// ThreadNode *Nextnode(ThreadNode *p)
// {
// //右子树中最左下节点
// if(p->rtag==0)
// return Firstnode(p->rchild);
// else 
// return p->rchild;//rtag==1直接返回后继线索
// }
// 
//找到中序后继的步骤
//如果有右子树：直接找到右子树的最左节点（即该节点的后继）。
//如果没有右子树：
//向上寻找：一直向上遍历，直到找到一个是其父节点的左孩子的节点，这个父节点就是当前节点的中序后继。如果到达根节点仍未找到，则没有后继。
//考虑以下的中序线索二叉树：
//
//    4
//   / \
//  2   6
// / \ / \
//1  3 5  7
//在上述树中，如果我们要找节点 3 的中序后继：
//
//3 没有右子树，因此我们要向上查找。3 是 2 的右孩子，因此我们继续向上查找 2 的父节点 4。
//4 是 2 的父节点中 2 的左孩子，所以 4 是 3 的中序后继。
//
//**************************
//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）
//void Inorder(ThreadNode* T)
//{
//	for (ThreadNode* p = Firstnode(T); p != NULL; p = Nextnode(p))
//		visit(p);
//}
//*******************************
//中序线索二叉树找中序前驱
//找到以p为根的子树中，最后一个被中序遍历的节点
//ThreadNode* Lastnode(ThreadNode* p)
//{
//	//循环找到最右下的节点(不一定是叶子节点）
//	while (p->rtag == 0)
//	{
//		p = p->rchild;
//	}
//	return p;
//}
//ThreadNode* Prenode(ThreadNode* p)
//{
//	//左子树中最右下节点
//	if (p->ltag == 0)
//		return Lastnode(p->lchild);
//	else
//		return p->lchild;//ltag==1直接返回前驱线索
//}
//对中序线索二叉树进行逆向中序遍历
//void RevInorder(ThreadNode* T)
//{
//	for (ThreadNode* p = Lastnode(T); p != NULL; p = Prenode(p))
//	{
//		visit(p);
//	}
//}
//**********************
// 先序遍历找先序前驱
// p->ltag==0的情况
//先序遍历中（根 左 右）左右子树中的节点只可能是根的后继，不可能是根的前驱
//所以肯定找不到前驱，只能找到后继
//除非从头开始重新遍历
//所以就有了三叉链表//多设置一个指向父节点的指针
//有四种情况：
//1.如果能找到p的父节点，且p是左孩子
//2.如果能找到p的父节点，且p是右孩子，其左兄弟为空
//3.如果能找到p的父节点，且p是右孩子，其左兄弟非空
//4.如果p是根节点，则p没有先序前驱
//*************************************
//后续线索二叉树找后续前驱(左，右，根）
//p->ltag==0的情况（一定有右孩子）
//若p有右孩子，则后序前驱为右孩子
//若p没有右孩子，则后序前驱为左孩子
//找后续后继next
//p->rtag==1,则next=p->rchild
//p->rtag==0.因为最后一个是根节点所以，没法找根节点后继
//又和上面一样用三叉链表
//1.如果能找到p的父节点，且p是右孩子
//后序遍历--（左右根）
//            左（左右 根 ）根（空格隔开的那个是目标节点p）
//p的父节点即为其后继
//2.如果能找到p的父节点，且p是左孩子，其右兄弟为空
//后续遍历---左 根 
//          （左右 根 ）根 
//p的父节点即为其后继
//3.如果能找到p的父节点，且p是左孩子，其右兄弟非空
//后续遍历---左 右 根
//p的后继为右兄弟子树中第一个被后序遍历的节点
//如果p是根节点，则p没有后序后继。

